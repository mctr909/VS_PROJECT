<html>
	<head>
		<title>WebGL TEST</title>
		<script type="text/javascript" src="script/math.js"></script>
		<script type="text/javascript" src="script/script.js"></script>
		<script type="text/javascript">
			let gCount = 0;
			let gRange = null;
			let gRender = null;

			(function() {
				window.requestAnimationFrame =
					window.requestAnimationFrame || 
					window.mozRequestAnimationFrame ||
					window.webkitRequestAnimationFrame || 
					window.msRequestAnimationFrame
				;
			})();

			onload = function() {
				gRange = document.getElementById('range');
				gRender = new Render(document.getElementById("canvas"), 800, 600);
				(function loop() {
					gCount = ++gCount % (6 * 360);

					//
					let rad = gCount * Math.PI / 360;
					let time = gRange.value / 100;
					let qtnA = new Qtn();
					let qtnB = new Qtn();
					Qtn.rotate(3 * rad, [3.0, 2.0, 1.0], qtnA);
					Qtn.rotate(2 * rad, [3.0, 2.0, 1.0], qtnB);

					gRender.pushMessage(RenderMsgId.BindModel, 1);

					//
					let matModel = new Mat();
					qtnA.toMat(matModel);
					Mat.translate(matModel, [0.0, 0.0, -30.0], matModel);
					gRender.pushMessage(RenderMsgId.DrawModel, matModel.Copy);

					//
					qtnB.toMat(matModel);
					Mat.translate(matModel, [0.0, 0.0, -30.0], matModel);
					gRender.pushMessage(RenderMsgId.DrawModel, matModel.Copy);

					for (let i = 0.0; i <= 1.0; i += 0.01) {
						let qtnS = new Qtn();
						Qtn.slerp(qtnA, qtnB, i, qtnS);
						qtnS.toMat(matModel);
						Mat.translate(matModel, [0.0, 0.0, -30.0], matModel);
						gRender.pushMessage(RenderMsgId.DrawModel, matModel.Copy);
					}

					//
					gRender.pushMessage(RenderMsgId.BindModel, 0);
					let qtnS = new Qtn();
					Qtn.slerp(qtnA, qtnB, time, qtnS);
					qtnS.toMat(matModel);
					Mat.translate(matModel, [0.0, 0.0, -30.0], matModel);
					gRender.pushMessage(RenderMsgId.DrawModel, matModel.Copy);

					gRender.main();
					window.requestAnimationFrame(loop);
				})();
			};
		</script>
		<script id="vs" type="x-shader/x-vertex">
			attribute vec3 position;
			attribute vec3 normal;
			attribute vec4 color;
			uniform   mat4 mvpMatrix;
			uniform   mat4 mMatrix;
			varying   vec3 vPosition;
			varying   vec3 vNormal;
			varying   vec4 vColor;

			void main(void){
				vPosition   = (mMatrix * vec4(position, 1.0)).xyz;
				vNormal	 = normal;
				vColor	  = color;
				gl_Position = mvpMatrix * vec4(position, 1.0);
			}
		</script>
		<script id="fs" type="x-shader/x-fragment">
			precision mediump float;

			uniform mat4 invMatrix;
			uniform vec3 lightPosition;
			uniform vec3 eyeDirection;
			uniform vec4 ambientColor;
			varying vec3 vPosition;
			varying vec3 vNormal;
			varying vec4 vColor;

			void main(void){
				vec3  lightVec  = lightPosition - vPosition;
				vec3  invLight  = normalize(invMatrix * vec4(lightVec, 0.0)).xyz;
				vec3  invEye	= normalize(invMatrix * vec4(eyeDirection, 0.0)).xyz;
				vec3  halfLE	= normalize(invLight + invEye);
				float diffuse   = clamp(dot(vNormal, invLight), 0.0, 1.0) + 0.2;
				float specular  = pow(clamp(dot(vNormal, halfLE), 0.0, 1.0), 50.0);
				vec4  destColor = vColor * vec4(vec3(diffuse), 1.0) + vec4(vec3(specular), 1.0) + ambientColor;
				gl_FragColor	= destColor;
			}
		</script>
	</head>
	<body>
		<canvas id="canvas"></canvas>
		<p><input id="range" type="range" value="50"> time value (0 to 1)</p>
	</body>
</html>